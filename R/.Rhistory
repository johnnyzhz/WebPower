probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_c2[, 1] = quantile(boot_c2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_d2[, 1] = quantile(boot_d2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CI1[, 1] = quantile(boot_CI1,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CI2[, 1] = quantile(boot_CI2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
r_CI = as.numeric(!sapply(1,function(i) dplyr::between(0,interval_CI[1,i], interval_CI[2,i])))
r_DI = as.numeric(!sapply(1,function(i) dplyr::between(0,interval_CD[1,i], interval_CD[2,i])))
r_c2 = as.numeric(!sapply(1, function(i) dplyr::between(0,interval_c2[1,i], interval_c2[2,i])))
r_d2 = as.numeric(!sapply(1, function(i) dplyr::between(0,interval_d2[1,i], interval_d2[2,i])))
if (method == "joint"){
r_CI = as.numeric(!dplyr::between(0, interval_CI1[1,1], interval_CI1[2,1]))*as.numeric(!dplyr::between(0, interval_CI2[1,1], interval_CI2[2,1]))
}
power=c(r_CI, r_DI, r_c2, r_d2)
return(power)
}
if (ncore > 1){
CL1 = parallel::makeCluster(ncore)
parallel::clusterExport(CL1, c('a1', 'cp', 'b1', 'c1', 'd1', 'c2','d2',
'sigx2', 'sigw2', 'sige12', 'sige22', 'sigx_w',
'n', 'nrep', 'alpha', 'b', 'nb', 'pop.cov',
'mu', 'w_value', 'method'), envir = environment())
allsim <- parallel::parLapply(CL1, 1:nrep, runonce)
parallel::clusterExport(CL1, 'allsim', envir=environment())
allsim1 = t(parallel::parSapply(CL1, 1:nrep, function(i) unlist(allsim[[i]])))
power <- colMeans(allsim1)
parallel::stopCluster(CL1)
}else{
allsim <- sapply(1:nrep, runonce)
power <- colMeans(t(allsim))
}
power.structure = structure(list(n = n,
alpha = alpha,
samples = nrep,
w = w_value,
power1 = power[1],
power2 = power[2],
power3 = power[3],
power4 = power[4],
method = "moderated mediation model 8",
url = "https://webpower.psychstat.org/models/modmed8/",
note="power1 is  the power of the conditional indirect effect of x on y through m.
power2 is the power value of the conditional direct effect of x on y.
power3 is the power of moderation on the path x to m.
power4 is the power of moderation on the path x to y."), class = "webpower")
return(power.structure)
}
wp.modmed.m8(n=100, nrep=100, w_value = -1, ncore = 5)
wp.modmed.m14(n=100, nrep=100, w_value = -1, ncore = 5)
#' @param pop.cov covariance matrix, default to NULL if using the regression coefficient approach
#' @param mu mean vector, default to NULL if using the regression coefficient approach
#' @param varnames name of variables for the covariance matrix
#' @return power of indirect effect, direct effect, and moderation
#' @export
#' @examples
#' test = wp.modmed.m14(a1 = 0.2, cp = 0.2, b1 = 0.5, d1 = 0.5, b2 = 0.2, sigx2 = 1,
#'                     sigw2 = 1, sige12 = 1, sige22 = 1, sigx_w = 0.5, n = 50,
#'                     nrep = 100, alpha = 0.05, b = 1000, ncore = 1)
#' print(test)
wp.modmed.m14 <- function (a1 = 0.2, cp = 0.2, b1 = 0.5, d1 = 0.5, b2 = 0.2,
sigx2 = 1, sigw2 = 1, sige12 = 1, sige22 = 1,
sigx_w = 0.5, n = 100, nrep = 100, alpha = 0.05,
b = 1000, nb = n, w_value = 0, method = "value",
ncore = 1, pop.cov = NULL, mu = NULL,
varnames =  c('y', 'x', 'w', 'm', 'mw'))
{
if (is.null(pop.cov) || is.null(mu)) {
sigm2 = a1^2*sigx2 + sige12
sigxw2 = sigx2*sigw2 + sigx_w^2
sigy2 = (cp + a1*b1)^2*sigx2 + d1^2*sigw2 + b2^2*sige12 *
sigw2 + (a1*b2)^2*sigxw2 + b1^2*sige12 + sige22 + 2*(cp + a1*b1)*d1*sigx_w
sigmw2 = a1^2*sigxw2 + sige12*sigw2
sigx_m = a1*sigx2
sigx_y = (cp + a1*b1)*sigx2 + d1*sigx_w
sigm_y = a1*(cp + a1*b1)*sigx2 + a1*d1*sigx_w + b1*sige12
sigm_w = a1*sigx_w
sigy_w = (cp + a1*b1)*sigx_w + d1*sigw2
sigy_mw = a1^2*b2*sigxw2 + b2*sige12*sigw2
# y, x, w, m, mw
pop.cov = array(
c(sigy2, sigx_y, sigy_w, sigm_y, sigy_mw,
sigx_y, sigx2, sigx_w, sigx_m, 0,
sigy_w, sigx_w, sigw2, sigm_w, 0,
sigm_y, sigx_m, sigm_w, sigm2, 0,
sigy_mw, 0, 0, 0, sigmw2),
dim = c(5, 5)
)
u_mw = a1*sigx_w
u_y = a1*b2*sigx_w
colnames(pop.cov) = rownames(pop.cov) = c('y', 'x', 'w', 'm', 'mw')
mu = c(u_y, 0, 0, 0, u_mw)
}else{
pop.cov = pop.cov
mu = mu
colnames(pop.cov) = varnames
}
runonce <- function(i) {
simdata <- MASS::mvrnorm(n, mu = mu, Sigma = pop.cov)
simdata <- as.data.frame(simdata)
test_a <- lm(m ~ x, data = simdata)
test_b <- lm(y ~ x + m + w + mw, data = simdata)
bootstrap = function(i) {
boot_dataint = sample.int(n, nb, replace = T)
boot_data = simdata[boot_dataint, ]
test_boot1 = lm(m ~ x, data = boot_data)
test_boot2 = lm(y ~ x + m + w + mw, data = boot_data)
boot_CI = test_boot1$coefficients[2]*(test_boot2$coefficients[3] + test_boot2$coefficients[5]*w_value)
boot_CD = test_boot2$coefficients[2]
boot_b2 = as.numeric(test_boot2$coefficients[5])
boot_CI1 = test_boot1$coefficients[2]
boot_CI2 = (test_boot2$coefficients[3] + test_boot2$coefficients[5]*w_value)
return(list(boot_CI, boot_CD, boot_b2, boot_CI1, boot_CI2))
}
boot_effect = lapply(1:b, bootstrap)
boot_CI = matrix(0, ncol = 1, nrow = b)
boot_CD = matrix(0, ncol = 1, nrow = b)
boot_b2 = matrix(0, ncol = 1, nrow = b)
boot_CI1 = matrix(0, ncol = 1, nrow = b)
boot_CI2 = matrix(0, ncol = 1, nrow = b)
boot_CI = t(sapply(1:b, function(i) unlist(boot_effect[[i]][1])))
boot_CD = t(sapply(1:b, function(i) unlist(boot_effect[[i]][2])))
boot_b2 = t(sapply(1:b, function(i) unlist(boot_effect[[i]][3])))
boot_CI1 = t(sapply(1:b, function(i) unlist(boot_effect[[i]][4])))
boot_CI2 = t(sapply(1:b, function(i) unlist(boot_effect[[i]][5])))
interval_CI = matrix(0, ncol = 1, nrow = 2)
interval_CI1 = matrix(0, ncol = 1, nrow = 2)
interval_CI2 = matrix(0, ncol = 1, nrow = 2)
interval_CD = matrix(0, ncol = 1, nrow = 2)
interval_b2 = matrix(0, ncol = 1, nrow = 2)
interval_CI[, 1] = quantile(boot_CI,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CI1[, 1] = quantile(boot_CI1,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CI2[, 1] = quantile(boot_CI2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CD[, 1] = quantile(boot_CD,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_b2[, 1] = quantile(boot_b2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
r_CI = as.numeric(!sapply(1, function(i) dplyr::between(0, interval_CI[1, i], interval_CI[2, i])))
r_CD = as.numeric(!sapply(1, function(i) dplyr::between(0, interval_CD[1, i], interval_CD[2, i])))
r_b2 = as.numeric(!sapply(1, function(i) dplyr::between(0, interval_b2[1, i], interval_b2[2, i])))
if (method == "joint") {
r_CI = as.numeric(!dplyr::between(0, interval_CI1[1, 1], interval_CI1[2, 1]))*as.numeric(!dplyr::between(0, interval_CI2[1, 1], interval_CI2[2, 1]))
}
power = c(r_CI, r_CD, r_b2)
return(power)
}
if (ncore > 1){
CL1 = parallel::makeCluster(ncore)
parallel::clusterExport(
CL1,
c('a1', 'cp', 'b1', 'd1', 'b2', 'sigx2', 'sigw2',
'sige12', 'sige22', 'sigx_w', 'n', 'nrep',
'alpha', 'b','nb', 'pop.cov', 'mu', 'method'
),
envir = environment()
)
allsim <- parallel::parLapply(CL1, 1:nrep, runonce)
parallel::clusterExport(CL1, 'allsim', envir = environment())
allsim1 = t(parallel::parSapply(CL1, 1:nrep, function(i)
unlist(allsim[[i]])))
power <- colMeans(allsim1)
parallel::stopCluster(CL1)
}else{
allsim <- sapply(1:nrep, runonce)
power <- colMeans(t(allsim))
}
power.structure = structure(
list(
n = n,
alpha = alpha,
samples = nrep,
w = w_value,
power1 = power[1],
power2 = power[2],
power3 = power[3],
method = "moderated mediation model 14",
url = "https://webpower.psychstat.org/models/modmed14/",
note = "power1 is the power of the conditional indirect effect of x on y through m.
power2 is the power value of the direct effect of x on y.
power3 is the power of moderation on the path m to y."
),
class = "webpower"
)
return(power.structure)
}
wp.modmed.m14(n=100, nrep=100, w_value = -1, ncore = 5)
wp.modmed.m15(n=100, nrep=100, w_value = -1, ncore = 5)
#' @param pop.cov covariance matrix, default to NULL if using the regression coefficient approach
#' @param mu mean vector, default to NULL if using the regression coefficient approach
#' @param varnames name of variables for the covariance matrix
#' @return power of indirect effect, direct effect, and moderation
#' @export
#' @examples
#' test = wp.modmed.m15(a1 = 0.6, cp = 0.2, b1 = 0.3, b2 = 0.2, d1 = 0.2, d2 = 0.1,
#'                      sigx2 = 1, sigw2 = 1, sige12 = 1, sige22 = 1, sigx_w = 0.4,
#'                      n = 50, nrep = 100, alpha = 0.05, b = 1000, ncore = 1)
#'print(test)
wp.modmed.m15 <- function(a1 = 0.6, cp = 0.2, b1 = 0.3, b2 = 0.5, d1 = 0.2, d2 = 0.1,
sigx2 = 1, sigw2 = 1, sige12 = 1, sige22 = 1, sigx_w = 0.4,
n = 100, nrep = 100, alpha = 0.05, b = 1000, nb = n,
w_value = 0, method = "value", ncore = 1,
pop.cov = NULL, mu = NULL,
varnames = c('y','x','w','m','xw','mw'))
{
if (is.null(pop.cov) || is.null(mu)){
sigxw2 = sigx2*sigw2 + sigx_w^2
sigm_xw = 0
sigy_xw = (d2 + a1*b2)*sigxw2
sigm_x = a1*sigx2
sigm_w = a1*sigx_w
sigy_x = d1*sigx_w + (cp + a1*b1)*sigx2
sigy_w = d1*sigw2 + (cp + a1*b1)*sigx_w
sige1w2 = sige12*sigw2
sigy2 = (cp + a1*b1)^2*sigx2 + (d2 + a1*b2)^2*sigxw2 + b2 ^
2*sige1w2 + d1^2*sigw2 + 2*d1*(cp + a1*b1)*sigx_w + b1^2 *
sige12 + sige22
sigm2 = a1^2*sigx2 + sige12
sigy_m = a1*(cp + a1*b1)*sigx2 + a1*d1*sigx_w + b1*sige12
sigy_mw = a1*(d2 + a1*b2)*sigxw2 + b2*sige1w2
sigxw_mw = a1*sigxw2
sigmw2 = a1^2*sigxw2 + sige1w2
pop.cov=array(c(sigy2, sigy_x, sigy_w, sigy_m, sigy_xw, sigy_mw, b1*sige12, sige22,
sigy_x, sigx2, sigx_w, sigm_x, 0, 0, 0, 0,
sigy_w, sigx_w, sigw2, sigm_w, 0, 0, 0, 0,
sigy_m, sigm_x, sigm_w, sigm2, sigm_xw, 0, sige12, 0,
sigy_xw, 0, 0, sigm_xw, sigxw2, sigxw_mw, 0, 0,
sigy_mw, 0, 0, 0, sigxw_mw, sigmw2, 0, 0,
b1*sige12, 0, 0, sige12, 0, 0, sige12, 0,
sige22, 0, 0, 0, 0, 0, 0, sige22),
dim = c(8, 8))
pop.cov = pop.cov[1:6, 1:6]
rownames(pop.cov) = colnames(pop.cov) = c('y', 'x', 'w', 'm', 'xw', 'mw')
u_xw = sigx_w
u_mw = sigm_w
u_y = d2*u_xw + b2*u_mw
mu = c(u_y, 0, 0, 0, u_xw, u_mw)
}else{
pop.cov = pop.cov
mu = mu
colnames(pop.cov) = varnames
}
runonce <- function(i){
simdata <- MASS::mvrnorm(n, mu = mu, Sigma = pop.cov)
simdata <- as.data.frame(simdata)
test_a <- lm(m ~ x, data = simdata)
test_b <- lm(y ~ x + m + w + xw + mw, data = simdata)
bootstrap=function(i){
boot_dataint = sample.int(n, nb, replace = T)
boot_data = simdata[boot_dataint, ]
test_boot1 = lm(m ~ x, data = boot_data)
test_boot2 = lm(y ~ x + m + w + xw + mw, data = boot_data)
boot_CI = (test_boot2$coefficients[3] + test_boot2$coefficients[6]*w_value)*test_boot1$coefficients[2]
boot_CD = test_boot2$coefficients[2] + test_boot2$coefficients[5]*w_value
boot_d2 = test_boot2$coefficients[5]
boot_b2 = test_boot2$coefficients[6]
boot_CI1 = test_boot1$coefficients[2]
boot_CI2 = (test_boot2$coefficients[3] + test_boot2$coefficients[6]*w_value)
return(list(boot_CI, boot_CD, boot_d2, boot_b2, boot_CI1, boot_CI2))
}
boot_effect = lapply(1:b, bootstrap)
boot_CI = matrix(0, ncol = 1, nrow = b)
boot_CI1 = matrix(0, ncol = 1, nrow = b)
boot_CI2 = matrix(0, ncol = 1, nrow = b)
boot_CD = matrix(0, ncol = 1, nrow = b)
boot_d2 = matrix(0, ncol = 1, nrow = b)
boot_b2 = matrix(0, ncol = 1, nrow = b)
boot_CI=t(sapply(1:b,function(i) unlist(boot_effect[[i]][1])))
boot_CD=t(sapply(1:b,function(i) unlist(boot_effect[[i]][2])))
boot_d2=t(sapply(1:b,function(i) unlist(boot_effect[[i]][3])))
boot_b2=t(sapply(1:b,function(i) unlist(boot_effect[[i]][4])))
boot_CI1=t(sapply(1:b,function(i) unlist(boot_effect[[i]][5])))
boot_CI2=t(sapply(1:b,function(i) unlist(boot_effect[[i]][6])))
interval_CI=matrix(0,ncol=1,nrow=2)
interval_CI1=matrix(0,ncol=1,nrow=2)
interval_CI2=matrix(0,ncol=1,nrow=2)
interval_CD=matrix(0,ncol=1,nrow=2)
interval_d2=matrix(0,ncol=1,nrow=2)
interval_b2=matrix(0,ncol=1,nrow=2)
interval_CI[, 1] = quantile(boot_CI,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CI1[, 1] = quantile(boot_CI1,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CI2[, 1] = quantile(boot_CI2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CD[, 1] = quantile(boot_CD,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_d2[, 1] = quantile(boot_d2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_b2[, 1] = quantile(boot_b2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
r_CI=as.numeric(!sapply(1,function(i) dplyr::between(0,interval_CI[1,i],interval_CI[2,i])))
r_DI=as.numeric(!sapply(1,function(i) dplyr::between(0,interval_CD[1,i],interval_CD[2,i])))
r_d2=as.numeric(!sapply(1:1,function(i) dplyr::between(0,interval_d2[1,i],interval_d2[2,i])))
r_b2=as.numeric(!sapply(1:1,function(i) dplyr::between(0,interval_b2[1,i],interval_b2[2,i])))
if (method =="joint"){
r_CI=as.numeric(!dplyr::between(0,interval_CI1[1,1],interval_CI1[2,1]))*as.numeric(!dplyr::between(0,interval_CI2[1,1],interval_CI2[2,1]))
}
power=c(r_CI,r_DI, r_d2, r_b2)
return(power)
}
if (ncore > 1){
CL1=parallel::makeCluster(ncore)
parallel::clusterExport(CL1,c('a1','c','b1','b2','d1','d2',
'sigx2','sigw2','sige12','sige22','sigx_w',
'n','nrep','alpha','b','nb','pop.cov','u_y','u_xw',
'u_mw', 'mu', 'method', 'w_value'),envir = environment())
allsim <- parallel::parLapply(CL1,1:nrep, runonce)
parallel::clusterExport(CL1,'allsim',envir=environment())
allsim1=t(parallel::parSapply(CL1,1:nrep,function(i) unlist(allsim[[i]])))
power <- colMeans(allsim1)
parallel::stopCluster(CL1)
}else{
allsim <- sapply(1:nrep, runonce)
power <- colMeans(t(allsim))
}
power.structure=structure(list(n = n,
alpha = alpha,
samples = nrep,
w = w_value,
power1 = power[1],
power2 = power[2],
power3 = power[3],
power4 = power[4],
method="moderated mediation model 15",
url = "https://webpower.psychstat.org/models/modmed15/",
note = "power1 is the power value of the conditional indirect effect of x on y.
power2 is the power value of the conditional direct effect of x on y.
power3 is the power of moderation on the path x to y.
power4 is the power of moderation on the path m to y."), class = "webpower")
return(power.structure)
}
wp.modmed.m15(n=100, nrep=100, w_value = -1, ncore = 5)
wp.modmed.m58(n=100, nrep=100, w_value = -1, ncore = 5)
#' @param mu mean vector, default to NULL if using the regression coefficient approach
#' @param varnames name of variables for the covariance matrix
#' @return power of indirect effect, direct effect, and moderation
#' @export
#' @examples
#' test = wp.modmed.m58(c1 = 0.2, a1 = 0.2, c2 = 0.1, b2 = 0.1,
#'      b1 = 0.2, cp = 0.2, d1 = 0.2,
#'      sigx2 = 1, sigw2 = 1, sige12 = 1, sige22 = 1, sigx_w = 0.5,
#'      n = 50, nrep = 100, alpha = 0.05, b = 1000, ncore = 1)
#' print(test)
wp.modmed.m58 <- function(c1 = 0.5, a1 = 0.75, c2 = 0.1, d1 = 0.4, b1 = 0.6, b2 = 0.1,
cp = 0.5, sigx2 = 1, sigw2 = 1, sige12 = 1, sige22 = 1, sigx_w = 0.4,
n = 100, nrep = 100, alpha = 0.05, b = 1000, nb = n,
w_value = 0, method = "value", ncore = 1,
pop.cov = NULL, mu = NULL, varnames =  c('x', 'w', 'm', 'xw', 'mw', 'y'))
{
if (is.null(pop.cov) || is.null(mu)){
sigx_m = a1*sigx2 + c1*sigx_w
sigx_mw = c2*(1 + 2*sigx_w^2 / sigx2 / sigw2)*sigx2*sigw2
sigx_y = d1*sigx_w + cp*sigx2 + b1*sigx_m + b2*sigx_mw
sigx_xw = sigw_xw = 0
sigw2 = sigw2
sigw_m = a1*sigx_w + c1*sigw2
sigw_mw = 3*c2*sigx_w / sqrt(sigx2) / sqrt(sigw2)*sqrt(sigx2)*(sqrt(sigw2))^3
sigw_y = d1*sigw2 + cp*sigx_w + b1*sigw_m + b2*sigw_mw
sigxw2 = sigx2*sigw2 + sigx_w^2
sigxw_w2 = 3*sigx_w*sigw2 - sigx_w*sigw2
sigm2 = a1^2*sigx2 + c1^2*sigw2 + c2^2*sigxw2 + sige12 +
2*a1*c1*sigx_w
sigm_xw = c2*sigxw2
sigm_mw = a1*c2*(sigx2*sigw2 + 2*sigx_w^2) + 3*c1*c2*sigx_w*sigw2 + c2*a1*sigxw2 + c2*c1*sigxw_w2
sigm_y = (d1 + c1*b1)*sigw_m + (cp + a1*b1)*sigx_m + b1*c2*sigm_xw + b2*sigm_mw + b1*sige12
sigxw_mw = a1*sigxw2 + c1*(3*sigx_w*sigw2 - sigx_w*sigw2)
sigxw_y = (d1 + c1*b1)*sigw_xw + (cp + a1*b1)*sigx_xw + b1*c2*sigxw2 + b2*sigxw_mw
sigxw22 = 3*sigx2*sigw2^2 - 3*sigx_w^2*sigw2 + 15*sigx_w^2*sigw2
sige1w2 = sige12*sigw2
sigmw2 = a1^2*sigxw2 + 2*c1^2*sigw2^2 + c2^2*sigxw22 + sige1w2 + 2*a1*c1*sigxw_w2
sigmw_y = (d1 + c1*b1)*sigw_mw + (cp + a1*b1)*sigx_mw + b1*c2*sigxw_mw + b2*sigmw2
sigy2 = (d1 + c1*b1)^2*sigw2 + (cp + a1*b1)^2*sigx2 + (b1*c2)^2*sigxw2 + b2^2*sigmw2 + b1^2*sige12 + sige22 + 2*(d1 + c1*b1)*(cp + a1*b1)*sigx_w + 2*(d1 + c1*b1)*b1*c2*sigw_xw + 2*(d1 + c1*b1)*b2*sigw_mw + 2*(cp + a1*b1)*b2*sigx_mw + 2*b1*c2*b2*sigxw_mw
pop.cov=array(c(sigx2, sigx_w, sigx_m, sigx_xw, sigx_mw, sigx_y, 0, 0,
sigx_w, sigw2, sigw_m, sigw_xw, sigw_mw, sigw_y, 0, 0,
sigx_m, sigw_m, sigm2, sigm_xw, sigm_mw, sigm_y, sige12, 0,
sigx_xw, sigw_xw, sigm_xw, sigxw2, sigxw_mw, sigxw_y, 0, 0,
sigx_mw, sigw_mw, sigm_mw, sigxw_mw, sigmw2, sigmw_y, 0, 0,
sigx_y, sigw_y, sigm_y, sigxw_y, sigmw_y, sigy2, b1*sige12, sige22,
0, 0, sige12, 0, 0, b1*sige12, sige12, 0,
0, 0, 0, 0, 0, sige22, 0, sige22), dim=c(8, 8))
pop.cov = pop.cov[1:6, 1:6]
u_xw = sigx_w
u_m = c2*u_xw
u_mw = a1*u_xw + c1*sigw2
u_y = b1*u_m + b2*u_mw
mu = c(0, 0, u_m, u_xw, u_mw, u_y)
rownames(pop.cov) = colnames(pop.cov) = c('x', 'w', 'm', 'xw', 'mw', 'y')
}else{
pop.cov = pop.cov
mu = mu
colnames(pop.cov) = varnames
}
## conduct the analysis once
##bootstrap sampling
runonce <- function(i){
simdata <- MASS::mvrnorm(n, mu = mu, Sigma = pop.cov)
simdata <- as.data.frame(simdata)
test_a <- lm(m ~ x + w + xw, data = simdata)
test_b <- lm(y ~ x + m + w + mw, data = simdata)
bootstrap=function(i){
boot_dataint = sample.int(n, nb, replace = T)
boot_data = simdata[boot_dataint, ]
test_boot1 = lm(m ~ x + w + xw, data = boot_data)
test_boot2 = lm(y ~ x + m + w + mw, data = boot_data)
boot_CI = (test_boot1$coefficients[2] + test_boot1$coefficients[4]*w_value)*(test_boot2$coefficients[3] + test_boot2$coefficients[5]*w_value)
boot_CI1 = (test_boot1$coefficients[2] + test_boot1$coefficients[4]*w_value)
boot_CI2 = (test_boot2$coefficients[3] + test_boot2$coefficients[5]*w_value)
boot_DI = test_boot2$coefficients[2]
boot_c2 = test_boot1$coefficients[4]
boot_b2 = test_boot2$coefficients[5]
return(list(boot_CI, boot_DI, boot_c2, boot_b2, boot_CI1, boot_CI2))
}
boot_effect = lapply(1:b, bootstrap)
boot_CI = matrix(0, ncol = 1, nrow = b)
boot_CI1 = matrix(0, ncol = 1, nrow = b)
boot_CI2 = matrix(0, ncol = 1, nrow = b)
boot_DI = matrix(0, ncol = 1, nrow = b)
boot_c2 = matrix(0, ncol = 1, nrow = b)
boot_b2 = matrix(0, ncol = 1, nrow = b)
boot_CI = t(sapply(1:b,function(i) unlist(boot_effect[[i]][1])))
boot_DI = as.matrix(sapply(1:b,function(i) unlist(boot_effect[[i]][2])))
boot_c2 = as.matrix(sapply(1:b,function(i) unlist(boot_effect[[i]][3])))
boot_b2 = as.matrix(sapply(1:b,function(i) unlist(boot_effect[[i]][4])))
boot_CI1 = t(sapply(1:b,function(i) unlist(boot_effect[[i]][5])))
boot_CI2 = t(sapply(1:b,function(i) unlist(boot_effect[[i]][6])))
interval_CI = matrix(0, ncol = 1, nrow = 2)
interval_DI = matrix(0, ncol = 1, nrow = 2)
interval_c2 = matrix(0, ncol = 1, nrow = 2)
interval_b2 = matrix(0, ncol = 1, nrow = 2)
interval_CI1 = matrix(0, ncol = 1, nrow = 2)
interval_CI2 = matrix(0, ncol = 1, nrow = 2)
interval_CI[, 1] = quantile(boot_CI,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CI1[, 1] = quantile(boot_CI1,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_CI2[, 1] = quantile(boot_CI2,
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_DI[, 1] = quantile(boot_DI[, 1],
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_c2[, 1] = quantile(boot_c2[, 1],
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
interval_b2[, 1] = quantile(boot_b2[, 1],
probs = c(alpha / 2, 1 - alpha / 2),
names = T)
r_CI = as.numeric(!sapply(1,function(i) dplyr::between(0,interval_CI[1,i],interval_CI[2,i])))
r_DI = as.numeric(!sapply(1,function(i) dplyr::between(0,interval_DI[1,i],interval_DI[2,i])))
r_c2 = as.numeric(!sapply(1,function(i) dplyr::between(0,interval_c2[1,i],interval_c2[2,i])))
r_b2 = as.numeric(!sapply(1,function(i) dplyr::between(0,interval_b2[1,i],interval_b2[2,i])))
power = c(r_CI, r_DI, r_c2, r_b2)
if (method == "joint"){
r_CI = as.numeric(!dplyr::between(0,interval_CI1[1,1], interval_CI1[2,1]))*as.numeric(!dplyr::between(0, interval_CI2[1,1], interval_CI2[2,1]))
}
return(power)
}
if (ncore > 1){
CL1 = parallel::makeCluster(ncore)
parallel::clusterExport(CL1,c('c1', 'a1', 'c2', 'b2', 'b1', 'cp', 'd1',
'sigx2', 'sigw2', 'sige12', 'sige22', 'sigx_w',
'n', 'nrep', 'alpha','b','nb','pop.cov',
'mu', 'method', 'w_value'),envir = environment())
allsim <- parallel::parLapply(CL1, 1:nrep, runonce)
parallel::clusterExport(CL1, 'allsim', envir = environment())
allsim1 = t(parallel::parSapply(CL1, 1:nrep, function(i) unlist(allsim[[i]])))
power <- colMeans(allsim1)
parallel::stopCluster(CL1)
}else{
allsim <- sapply(1:nrep, runonce)
power <- colMeans(t(allsim))
}
power.structure=structure(list(n = n,
alpha = alpha,
samples = nrep,
w = w_value,
power1 = power[1],
power2 = power[2],
power3 = power[3],
power4 = power[4],
method = "moderated mediation model 58",
url = "https://webpower.psychstat.org/models/modmed58/",
note="power1 is the power of the conditional indirect effect of x on y through m.
power2 is  the power of the direct effect of x on y.
power3 is the power of moderation on the path x to m.
power4 is the power of moderation on the path m to y."), class = "webpower")
return(power.structure)
}
wp.modmed.m58(n=100, nrep=100, w_value = -1, ncore = 5)
